1. 面向对象编程
    特点: 封装 继承 多态      基本概念:类和实例.
    封装: 比如将js放在一个函数里,将一些数据放在数组里,放在对象里都是封装
    继承: 通过继承可以实现对现有代码的重用 例如：我们定义了一个Person对象，他包含了wolk()，sleep(),speak(),eat()等方法，
            也包含了age,height,weight等属性，这时当我们再定义一个coder对象的时候，你不必将上述的属性和方法都重写一遍，
            你只需继承他即可，然后你只需将coder这个对象属于他自己的那部分特殊功能写出来。
    多态: 同一操作作用于不同的对象上面，可以产生不同的解释和不同的执行结果,就是两个对象拥有某一个一样名称的方法

    类: 类是对象的类型模板,是一类相同事物的总称,类是一个抽象的概念.
    实例(对象): 实例是根据类创建的一个个体对象,是类的实例化
    原型: 在js中一切变量都可以被视为对象,每一个对象都有一个原型对象

2. 原型链
    JavaScript对每一个创建的对象都会设置一个原型,指向他的原型对象prototype,而指向的过程就叫原型链(函数也是个对象)
    数组他的原型链是:arr-->Array.prototype-->Object.prototype-->null
    原型链继承:将父类的实例作为子类的原型   Cat.prototype = new Animal('cat'); //cat的原型等于Animal新建的实例
    
    在javascript中，类的实现是基于其原型继承机制的。如果两个实例都从同一个原型对象上继承了属性，我们就说它们是同一个类的实例。
    那么，如果两个对象继承自同一个原型，那基本上可以认为它们是由同一个构造函数创建并初始化的。

3. 闭包
    它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。
    js的内存回收机制：一个函数在执行开始的时候,会给其中定义的变量划分内存空间保存,以备后面的语句所用,
        等到函数执行完毕返回了,这些变量就被认为是无用的了，对应的空间也就被回收了。下次再执行此函数的时候，
        所有的变量又回到最初的状态，重新赋值使用。但是如果这个函数内部又嵌套了另一个函数(这就是闭包了)，
        而这个函数是有可能在外部被调用到的。并且这个内部函数又使用了外部函数的某些变量的话.这种内存回收机制就会出现问题。
        如果在外部函数返回后，又直接调用了内部函数，那么内部函数就无法读取到他所需要的外部函数中变量的值了。
        所以js解释器在遇到函数定义的时候会自动把函数和他可能使用的变量(包括本地变量和父级和祖先级函数的变量(自由变量))一起保存起来。
        也就是构建一个闭包，这些变量将不会被内存回收器所回收，只有当内部的函数不可能被调用以后(例如被删除了,或者没有了指针)，
        才会销毁这个闭包,而没有任何一个闭包引用的变量才会被下一次内存回收启动时所回收。

4. RequireJS
    RequireJS 是一个对浏览器端代码进行模块拆分的解决方案。
    就是以前js文件太大,加载速率太慢,而进行的一个优化,它是按照AMD的规范来进行模块定义和模块导出的,

5. AMD/CMD
    AMD异步加载 RequireJS
    CMD同步加载 node

6. http的理解
    即超文本传输协议。它是web服务器常用一种通信协议。它主要包含两个结构:请求结构(报文)和响应结构(报文)。
    请求结构包含:请求行(请求方式和URL) 请求头 请求体 空行; 响应结构包括:响应行(状态码和状态描述信息) 响应头 响应体 空行。
    它是基于TCP的三次握手之后才能建立可靠链接。三次握手的过程:
        第一次:浏览器向服务端发起一个建立连接的请求报文，进入等待确认的状态;
        第二次:当服务端收到浏览器的请求报文之后，发送一个确认报文，然进入确认状态;
        第三次:浏览器收到服务端的确认报文之后，再次发送一个确认报文，进入连接状态。

7. Ajax
    它主要是为了解决form表单提交会刷新页面的导致用户体验差的问题。它也是目前web 应用开发必备的一项技术。

8. node的中间件
    中间件 Middle Wear 是指在服务端收到请求之后和在响应之前处理的操作。
    Node提供的中间件有很多，比如express.static、body-parser、router等

9. promise
    Promise是一种异步编程的解决方案，主要指用来解决一步操作结束的状态回调
    promise提供的状态信息是安全的，因为这种状态一旦确认便不可更改，且随时可以被捕获到
    var promise = new Promise(function(resolve, reject) {
    // 异步处理
    // 处理结束后、调用resolve 或 reject
    });
    promise.then(onFulfilled).catch(onRejected)

10. vue的双向数据绑定原理
    实现mvvm主要包含两个方面，数据变化更新视图，视图变化更新数据：
    view更新data其实可以通过事件监听即可，比如input标签监听 'input' 事件就可以实现了
    data更新view 通过Object.defineProperty( )对属性设置一个set函数，当数据改变了就会来触发这个函数

    Object.defineProperty(obj,prop,descriptor)方法会直接在一个对象上定义一个新属性,或者修改一个对象的现有属性,并返回这个对象。
    obj 要在其上定义属性的对象。 prop 要定义或修改的属性的名称。 escriptor 将被定义或修改的属性描述符。

11. webSockiet
    是一种全双工的网络通讯协议,一般用来做即时聊天,在连接中服务端可以主动往客户端发送信息,http协议服务端无法主动往客户端发送信息

12. 创建node服务器
    //加载
    var express = require('express')
    //创建
    var app = express();
    //设置静态目录
    app.use(express.static('sta'))
    //接收get请求
    app.get('/login',function(request,response){}
    //分配端口并监听
    app.listen(3000,function(){
        console.log("服务器启动了")
    })

13. JS是单线程的,一个线程中分两个队列,同步队列跟异步队列,运行时先执行同步队列再执行异步队列
    异步队列:事件绑定onclick,sehtimeout,ajax

14. 按值传递:字符串,布尔类型 是按值传递
    按引用传递:对象,数组,原型链  当复制的数改变时会影响被复制的数


15. web前端方面优化性能
    1)        HTML部分
    u 语义化HTML：好处在于可以使代码简洁清晰，支持不同设备，利于搜索引擎，便于团队开发；
    u 减少DOM节点：加速页面渲染；
    u 给图片加上正确的宽高值：这可以减少页面重绘，同时防止图片缩放；
    u 防止src属性和link的href属性为空：当值为空时，浏览器很可能会把当前页面当成其属性值加载；
    u 正确的闭合标签：如避免使用<div/>，浏览器会多一个将它解析成<div\></div\>的过程；
    u 链接为目录或首页的地址后面加”/”，如http://www.5icool.org/；
    u 用LINK而不用@import方式导入样式；
    u 样式放在页头，JS放在页尾；
    u 缩小favicon.ico并缓存；
    2)        CSS部分
    u 避免使用CSS Expressions(CSS表达式)：如background-color: expression( (newDate()).getHours()%2 ? “#B8D4FF” : “#F08A00″ ) ;
    u 避免使用CSS Filter（CSS滤镜）；
    u 使用CSS缩写，减少代码量；
    u 通过CSSSprites把同类图片合成一张，减少图片请求；
    u 减少查询层级：如.header .logo要好过.header .top .logo；
    u 减少查询范围：如.header>li要好过.header li；
    u 避免TAG标签与CLASS或ID并存：如a.top、button#submit；
    u 删除重复的CSS；
    3)        Javscript部分
    u 尽量少用全局变量；
    u 使用事件代理绑定事件，如将事件绑定在body上进行代理；
    u 避免频繁操作DOM节点；
    u 不使用EVAL；
    u 减少对象查找，如a.b.c.d这种查找方式非常耗性能，尽可能把它定义在变量里；
    u 类型转换：把数字转换成字符串使用”” + 1，浮点数转换成整型使用Math.floor()或者Math.round()；
    u 对字符串进行循环操作，譬如替换、查找，应使用正则表达式；
    u 删除重复的JS；
    4)        服务器部分
    u 尽量合并CSS、JS文件，或将其直接写在页面上，减少HTTP请求；
    u 压缩CSS、JS文件，缩短文件传输时间；
    u 避免404错误：特别要避免给404指定一个停摆页面，否则所有404错误都将会加载一次页面；
    u 一般要求减少DNS查询次数，如同一个页面的请求资源尽量少的使用不同的主机名，这可以减少网站并行下载的数量，但很多网站为了加速下载资源其实是特意用了多个主机名，这里要做一个权衡；
    u 使用CDN加速，使用户从离自己最近的服务器下载文件；
    u 减少Cookie的大小，使用无cookie的域，客户端请求静态文件的时候，减少 Cookie 的反复传输对主域名的影响；
    u 为文件头指定Expires，使内容具有缓存性；
    u 使用gzip压缩内容；

16. ES6
    变量的解构与赋值
    数组的展开 [...]

    let:声明一个变量。只在let命令所在的代码块内有效。
    const:声明一个只读的常量。一旦声明，常量的值就不能改变

    字符串的遍历
    for (let codePoint of 'foo') {
        console.log(codePoint)
    }

    模板字面量:${} 或者 ``

    函数:可以使用箭头函数,箭头函数的this指向是根据上下文获取   可以在传参数的时候给个默认值

    Proxy:代理  对一个空对象架设了一层拦截，重定义了属性的读取（get）和设置（set）

    class继承:Class 可以通过extends关键字实现继承
    <script>
        //定义一个类
        class Point{
            constructor(name){
                this.name = name
            }
            aaa(){
                console.log(this.name)
            }
        }
        //通过class继承
        class ColorPoint extends Point {
            constructor(name,money){
                //调用父类的属性
                super(name); 
                this.money = money
            }
            //新加的方法
            qwe(){
                console.log(this.money)
                console.log(999)
            }
        }
        var asd = new ColorPoint('566','asdsa')
        asd.qwe()
    </script>

    

